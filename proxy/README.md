###  代理模式: 
给某一个对象提供一个代理,并由代理对象控制对原对象的引用;代理模式中的角色: 
 1. Subject(抽象主题角色): 声明了真实主题和代理主题的共同接口,使得在任何使用真实主题的地方都可以使用代理主题,客户端针对抽象主题编程

 2. Proxy(代理主题角色): 代理主题内部维持了一个真实主题的引用;代理主题角色负责在需要的时候创建和删除真实主题对象,并对真实主题对象的使用加以约束,以便客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作;

 3. RealSubject(真实主题角色): 实现了真实业务操作;

###  jdk动态代理
动态代理是在运行时,在需要代理的地方,根据反射的原理,动态的创建一个Proxy对象,用完即销毁,解决了静态代理  
中Proxy角色class在系统中的冗余,可以实现对多个委托类的统一代理和集中控制;  
外界对Proxy角色中的每一个方法的调用,Proxy的角色都会交给Invocation来处理,而InvocationHandler则调用具体角色方法  

###  cglib子类代理  
cglib采用字节码技术,通过目标类的字节码为一个类创建子类,并在子类中采用方法拦截技术拦截所有的父类的方法的调用,顺势织入横切逻辑;底层使用字节码处理框架ASM,来转换字节码并生成新的类;

    代理类将目标类作为自己的父类并为其中的每个非final委托方法创建两个方法

        a. 一个与目标方法签名相同的方法,它在方法中会通过super调用目标方法;

        b. 另一个是代理类独有的方法,称之为Callback回调方法,它会判断这个方法是否绑定了拦截器(实现了MethodIntercept接口对象),若存在则将调用Intercept方法对目标方法进行代理,就是在前后加上一些增强逻辑,intercept中就会调用签名相同的方法.
###  JDK动态代理与CGLib代理的区别  
1. JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。  
2. JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。  
3. JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高